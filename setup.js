#!/usr/bin/env node

// NFT Marketplace Setup Script
// This script helps initialize the project with proper configuration

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const readline = require('readline');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

const log = {
  info: (msg) => console.log(`${colors.blue}â„¹${colors.reset} ${msg}`),
  success: (msg) => console.log(`${colors.green}âœ“${colors.reset} ${msg}`),
  warning: (msg) => console.log(`${colors.yellow}âš ${colors.reset} ${msg}`),
  error: (msg) => console.log(`${colors.red}âœ—${colors.reset} ${msg}`),
  title: (msg) => console.log(`\n${colors.bright}${colors.cyan}${msg}${colors.reset}\n`),
};

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const question = (query) => new Promise((resolve) => rl.question(query, resolve));

class NFTMarketplaceSetup {
  constructor() {
    this.projectRoot = __dirname;
    this.contractsDir = path.join(this.projectRoot, 'contracts');
    this.frontendDir = path.join(this.projectRoot, 'frontend');
    this.config = {};
  }

  async run() {
    try {
      log.title('ðŸš€ NFT Marketplace Setup');
      
      await this.checkPrerequisites();
      await this.gatherConfiguration();
      await this.setupEnvironmentFiles();
      await this.installDependencies();
      await this.displayNextSteps();
      
      log.success('Setup completed successfully!');
    } catch (error) {
      log.error(`Setup failed: ${error.message}`);
      process.exit(1);
    } finally {
      rl.close();
    }
  }

  async checkPrerequisites() {
    log.title('ðŸ“‹ Checking Prerequisites');
    
    // Check Node.js version
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
    
    if (majorVersion < 16) {
      throw new Error(`Node.js v16 or higher is required. Current version: ${nodeVersion}`);
    }
    log.success(`Node.js version: ${nodeVersion}`);
    
    // Check npm
    try {
      const npmVersion = execSync('npm --version', { encoding: 'utf8' }).trim();
      log.success(`npm version: ${npmVersion}`);
    } catch (error) {
      throw new Error('npm is not installed or not in PATH');
    }
    
    // Check Git
    try {
      const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
      log.success(`${gitVersion}`);
    } catch (error) {
      log.warning('Git is not installed. Version control features will be limited.');
    }
    
    // Check project structure
    if (!fs.existsSync(this.contractsDir)) {
      throw new Error('Contracts directory not found. Please run this script from the project root.');
    }
    
    if (!fs.existsSync(this.frontendDir)) {
      throw new Error('Frontend directory not found. Please run this script from the project root.');
    }
    
    log.success('All prerequisites met!');
  }

  async gatherConfiguration() {
    log.title('âš™ï¸ Configuration Setup');
    
    log.info('Please provide the following configuration details:');
    log.info('(Press Enter to use default values)');
    
    // Infura Project ID
    this.config.infuraProjectId = await question(
      `\n${colors.cyan}Infura Project ID${colors.reset} (for blockchain connectivity): `
    );
    
    // Pinata API Keys
    this.config.pinataApiKey = await question(
      `\n${colors.cyan}Pinata API Key${colors.reset} (for IPFS storage): `
    );
    
    this.config.pinataSecretKey = await question(
      `\n${colors.cyan}Pinata Secret Key${colors.reset}: `
    );
    
    // Etherscan API Key
    this.config.etherscanApiKey = await question(
      `\n${colors.cyan}Etherscan API Key${colors.reset} (for contract verification): `
    );
    
    // Private Key for deployment
    this.config.deployerPrivateKey = await question(
      `\n${colors.cyan}Deployer Private Key${colors.reset} (for contract deployment): `
    );
    
    // Marketplace fee
    const marketplaceFee = await question(
      `\n${colors.cyan}Marketplace Fee${colors.reset} in basis points (default: 250 = 2.5%): `
    );
    this.config.marketplaceFee = marketplaceFee || '250';
    
    log.success('Configuration collected!');
  }

  async setupEnvironmentFiles() {
    log.title('ðŸ“ Setting up Environment Files');
    
    // Setup contracts .env
    const contractsEnvPath = path.join(this.contractsDir, '.env');
    const contractsEnvContent = `# Smart Contract Environment Configuration
# Generated by setup script on ${new Date().toISOString()}

# Blockchain Configuration
INFURA_PROJECT_ID=${this.config.infuraProjectId || ''}
PRIVATE_KEY=${this.config.deployerPrivateKey || ''}
ETHERSCAN_API_KEY=${this.config.etherscanApiKey || ''}

# Contract Configuration
MARKETPLACE_FEE=${this.config.marketplaceFee}

# Network URLs
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/${this.config.infuraProjectId || 'YOUR_INFURA_PROJECT_ID'}
MAINNET_RPC_URL=https://mainnet.infura.io/v3/${this.config.infuraProjectId || 'YOUR_INFURA_PROJECT_ID'}

# Deployment Configuration
GAS_PRICE=20000000000
GAS_LIMIT=3000000
`;
    
    fs.writeFileSync(contractsEnvPath, contractsEnvContent);
    log.success('Created contracts/.env');
    
    // Update frontend .env
    const frontendEnvPath = path.join(this.frontendDir, '.env');
    let frontendEnvContent = fs.readFileSync(frontendEnvPath, 'utf8');
    
    // Update specific values
    if (this.config.infuraProjectId) {
      frontendEnvContent = frontendEnvContent.replace(
        /REACT_APP_INFURA_PROJECT_ID=.*/,
        `REACT_APP_INFURA_PROJECT_ID=${this.config.infuraProjectId}`
      );
    }
    
    if (this.config.pinataApiKey) {
      frontendEnvContent = frontendEnvContent.replace(
        /REACT_APP_PINATA_API_KEY=.*/,
        `REACT_APP_PINATA_API_KEY=${this.config.pinataApiKey}`
      );
    }
    
    if (this.config.pinataSecretKey) {
      frontendEnvContent = frontendEnvContent.replace(
        /REACT_APP_PINATA_SECRET_KEY=.*/,
        `REACT_APP_PINATA_SECRET_KEY=${this.config.pinataSecretKey}`
      );
    }
    
    if (this.config.marketplaceFee) {
      frontendEnvContent = frontendEnvContent.replace(
        /REACT_APP_MARKETPLACE_FEE=.*/,
        `REACT_APP_MARKETPLACE_FEE=${this.config.marketplaceFee}`
      );
    }
    
    fs.writeFileSync(frontendEnvPath, frontendEnvContent);
    log.success('Updated frontend/.env');
  }

  async installDependencies() {
    log.title('ðŸ“¦ Installing Dependencies');
    
    // Install contracts dependencies
    log.info('Installing smart contract dependencies...');
    try {
      execSync('npm install', { 
        cwd: this.contractsDir, 
        stdio: 'inherit' 
      });
      log.success('Smart contract dependencies installed');
    } catch (error) {
      log.error('Failed to install smart contract dependencies');
      throw error;
    }
    
    // Install frontend dependencies
    log.info('Installing frontend dependencies...');
    try {
      execSync('npm install', { 
        cwd: this.frontendDir, 
        stdio: 'inherit' 
      });
      log.success('Frontend dependencies installed');
    } catch (error) {
      log.error('Failed to install frontend dependencies');
      throw error;
    }
  }

  async displayNextSteps() {
    log.title('ðŸŽ¯ Next Steps');
    
    console.log(`${colors.bright}To get started with your NFT Marketplace:${colors.reset}\n`);
    
    console.log(`${colors.cyan}1. Start a local blockchain:${colors.reset}`);
    console.log(`   cd contracts`);
    console.log(`   npx hardhat node\n`);
    
    console.log(`${colors.cyan}2. Deploy smart contracts (in a new terminal):${colors.reset}`);
    console.log(`   cd contracts`);
    console.log(`   npx hardhat run scripts/deploy.js --network localhost\n`);
    
    console.log(`${colors.cyan}3. Start the frontend (in another terminal):${colors.reset}`);
    console.log(`   cd frontend`);
    console.log(`   npm start\n`);
    
    console.log(`${colors.cyan}4. Configure MetaMask:${colors.reset}`);
    console.log(`   - Add localhost network (Chain ID: 31337, RPC: http://127.0.0.1:8545)`);
    console.log(`   - Import a test account from Hardhat node output\n`);
    
    console.log(`${colors.cyan}5. Access the application:${colors.reset}`);
    console.log(`   - Frontend: http://localhost:3000`);
    console.log(`   - Hardhat Console: Available in contracts terminal\n`);
    
    if (!this.config.infuraProjectId) {
      log.warning('Remember to add your Infura Project ID for testnet/mainnet deployment');
    }
    
    if (!this.config.pinataApiKey) {
      log.warning('Remember to add Pinata API keys for IPFS functionality');
    }
    
    console.log(`\n${colors.bright}ðŸ“š Documentation:${colors.reset}`);
    console.log(`   - README.md: Complete setup and usage guide`);
    console.log(`   - contracts/: Smart contract documentation`);
    console.log(`   - frontend/: Frontend component documentation\n`);
    
    console.log(`${colors.bright}ðŸ”— Useful Commands:${colors.reset}`);
    console.log(`   - Test contracts: cd contracts && npm test`);
    console.log(`   - Compile contracts: cd contracts && npm run compile`);
    console.log(`   - Deploy to Sepolia: cd contracts && npm run deploy:sepolia`);
    console.log(`   - Build frontend: cd frontend && npm run build\n`);
  }

  static async init() {
    const setup = new NFTMarketplaceSetup();
    await setup.run();
  }
}

// Run setup if called directly
if (require.main === module) {
  NFTMarketplaceSetup.init().catch((error) => {
    console.error('Setup failed:', error);
    process.exit(1);
  });
}

module.exports = NFTMarketplaceSetup;